
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Lab &#34;SQL - Transaktionen: Fallstudie Webshop&#34;</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="None"
                  id="sql_transactions_webshop"
                  title="Lab &#34;SQL - Transaktionen: Fallstudie Webshop&#34;"
                  environment="web"
                  feedback-link="https://p-kueppers.com">
    
      <google-codelab-step label="Einführung" duration="2">
        <p>Wir arbeiten weiterhin mit der Webshop-Datenbank und diesem Schema:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\3ddc71d3b3fd5441.png"></p>
<h2 is-upgraded><strong>Motivation</strong></h2>
<p>In der Vorlesung haben wir einige Herausforderungen kennengelernt, die sich durch den Mehrbenutzerbetrieb in der notwendigen Synchronisation von Datenbankoperationen ergeben. In diesem Codelab möchten wir einige dieser Herausforderungen an unserem Webshop-Beispiel kennenlernen. </p>
<p>Insbesondere werden wir eine Transaktion definieren, die die folgenden vier Schritte zu einer atomaren Operation zusammenfasst. Schlägt einer dieser Schritte fehl (bspw. durch einen Programmierfehler aber vor allem durch externe Einflüsse, d.h. konkurrierende Zugriffe auf dieselben Daten in der Datenbank), so soll die gesamte Transaktion fehlschlagen und alle bisherigen Änderungen rückgängig gemacht werden (rollback).</p>
<p>Die vier Schritte leiten sich aus dem Workflow zur Überführung eines Warenkorbs in eine Bestellung in unserem Webshop ab: Wir nehmen an, dass ein User in der Weboberfläche auf &#34;kaufen&#34; geklickt hat und damit der aktuelle Warenkorb in eine echte Bestellung überführt werden soll. Die folgenden Schritte sind also notwendig (vgl. Abbildung unten):</p>
<ol type="1" start="1">
<li>Anlegen einer Bestellung inklusive</li>
<li>einer Zuordnung der Bestellung zum bestellenden Kunden sowie</li>
<li>Überführen aller Warenkorbpositionen in Bestellpositionen (d.h. Kopieren der Einträge aus Tabelle Warenkorbposition in Bestellposition mit korrekter Zuordnung zur neuen Bestellung) und letztlich</li>
<li>Löschen der Warenkorbpositionen, d.h. Leeren des Warenkorbs.</li>
</ol>
<p class="image-container"><img style="width: 624.00px" src="img\\df8fc2bd8e46844d.png"></p>
<p>Wir werden diese Schritte in einer Transaktion definieren und betrachten verschiedene Möglichkeiten des Transaktionsmanagements und der &#34;Isolation&#34; von Datenmanipulationen in der Datenbank.</p>
<h2 is-upgraded><strong>Dies werden Sie umsetzen</strong></h2>
<ul>
<li>Anlegen einer AI Platform Notebook-Instanz mit Jupyterlab / Jupyter Notebooks (identisch zu <a href="https://pkuep.github.io/hska-140-db/sql_dml_webshop/#2" target="_blank">https://pkuep.github.io/hska-140-db/sql_dml_webshop/#2</a>).</li>
<li>Konfiguration des Zugriffs auf die Übungsdatenbank mittels SSH-Tunnel - zur (1) erneuten Befüllung der Datenbank (optional) und (2) für diese Übung.</li>
<li>Laden eines Jupyter Notebooks, das den SQL-Quellcode und die Transaktion enthält und diese aus Python heraus an die Datenbank absetzt.</li>
<li>Testen verschiedener Datenbankeinstellungen und konkurrierender Zugriffe.</li>
</ul>
<aside class="warning"><p><strong>Hinweis:</strong> Sie benötigen für dieses Lab keine Cloud SQL-Instanz.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Starten bzw. Anlegen Jupyterlab-Instanz sowie Laden des vorgegebenen Quellcodes" duration="12">
        <h2 is-upgraded><strong>Nutzung der existierenden Notebook-Instanz</strong></h2>
<p>Im <a href="https://pkuep.github.io/hska-140-db/sql_dml_webshop/" target="_blank">Codelab zur DML</a> haben wir eine Jupyter Notebook-Instanz angelegt. Falls diese noch existiert, dann starten Sie sie bitte. Sie können dann zum nächsten Schritt wechseln. Ansonsten fahren Sie bitte mit den folgenden Schritten fort.</p>
<h2 is-upgraded><strong>Erstellung der Notebook-Instanz </strong></h2>
<p>Bitte klicken Sie auf &#34;AI-Plattform&#34; unter &#34;Artificial Intelligence&#34; und dann auf Notebooks:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\87fa7358c26a76b2.png"></p>
<p>Sie sollten die entsprechende API im ersten Codelab bereits aktiviert haben. Falls nicht, erhalten SIe eine Meldung, bei der SIe &#34;Enable API&#34; klicken müssen.</p>
<p>Wir legen nun eine neue Instanz an. Eine Instanz ist in diesem Fall eine virtuelle Maschine, die gestartet wird, auf der Jupyter installiert wird und es wird eingestellt, dass wir auf extern auf die Jupyter Notebooks zugreifen können. Klicken Sie auf &#34;New Instance&#34;:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\2976d57c7eb7867b.png"></p>
<p>Wählen Sie &#34;Python 2 and 3&#34; aus:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\5e926345752d4063.png"></p>
<p>Benennen Sie die Instanz bspw. &#34;&lt;Ihre Initialien&gt;-notebook&#34;, in meinem Fall also bspw. &#34;pk-notebook&#34;. Selektieren Sie die Region &#34;us-central1&#34; - dies ist in vielen GCP-Diensten die Standardregion, in der wir alle Funktionen laufen lassen möchten:</p>
<p class="image-container"><img style="width: 401.14px" src="img\\619707c98dc9e96c.png"></p>
<p>Warten Sie so lange, bis in der Übersicht der Zugriff auf das Web Interface angezeigt wird:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\3794ea6b4aab4415.png"></p>
<p>Klicken Sie auf &#34;Open Jupyterlab&#34;.</p>
<aside class="warning"><p><strong>Warnung: </strong>Der Betrieb der Notebook-Instanz ist kostenpflichtig. Denken Sie daran, diese im Anschluss an diese Übung so wie die Cloud SQL-Instanz auszuschalten.</p>
</aside>
<h2 is-upgraded><strong>Zugriff auf das JupyterLab</strong></h2>
<p>Wenn Sie auf &#34;Open Jupyterlab&#34; geklickt haben, sollte folgende Übersicht erscheinen. Bitte legen Sie ein neues &#34;Python 3&#34; Notebook an:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\cdf7bcd2620d4eea.png"></p>
<p>Ein neues Tab sollte sich öffnen, in dem Sie nun mit der Programmierung loslegen können:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\8d17d917de1e2e60.png"></p>
<p>Speichern Sie das Notebook bitte unter dem Namen &#34;Setup&#34; ab, da wir im Folgenden ein paar Installations- und Konfigurationsbefehle nutzen möchten.</p>
<h2 is-upgraded><strong>Installation des MySQL-Treibers</strong></h2>
<p>Wir werden das Paket &#34;mysql-connector&#34; als MySQL-Treiber für Python verwenden. Dieses ist leider nicht im Standard auf der Jupyterlab-Instanz installiert. Geben Sie folgenden Code ein, um den Treiber über das Python Package Management (pip) zu installieren:</p>
<pre><code># Installation des MySQL-Treibers für Python
# Diese Zelle muss nur einmalig ausgeführt werden. Sollten Sie Ihre Instanz löschen
# und eine neue anlegen, dann muss dieser Code erneut ausgeführt werden.
!pip install mysql-connector</code></pre>
<p>Folgendes sollte die Ausgabe sein:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\fb7b35b7233bc3da.png"></p>
<aside class="warning"><p><strong>Wichtig: </strong>Diesen Befehl müssen Sie nur einmalig ausführen, es sei denn, Sie löschen die Instanz und legen eine neue an.</p>
</aside>
<h2 is-upgraded><strong>Laden des Quellcodes</strong></h2>
<p>In GitHub (Plattform zum Code-Sharing und kollaborativen Entwickeln) finden sich zwei Jupyter-Notebooks und eine SQL-Codedatei (Repository <a href="https://github.com/pkuep/hska-dscb140-code" target="_blank">https://github.com/pkuep/hska-dscb140-code</a>), die wir im Folgenden für das Datenbank-Setup verwenden möchten. Mit folgendem Befehl, den Sie bitte in einer neuen Zelle im Notebook &#34;Setup&#34; ausführen, laden wir diese Dateien in ein neues Verzeichnis &#34;hska-dscb140-code&#34; herunter.</p>
<pre><code># Initiales &#34;Klonen&#34; des GitHub-Repositories für DSCB140
!git clone https://github.com/pkuep/hska-dscb140-code.git</code></pre>
<p>Die Ausgabe sollte wie folgt aussehen (ein neuer Ordner sollte angelegt worden sein):</p>
<p class="image-container"><img style="width: 624.00px" src="img\\133db3e086debcfa.png"></p>
<aside class="warning"><p><strong>Wichtig: </strong>Diesen Befehl müssen Sie nur einmalig ausführen, es sei denn, Sie löschen die Instanz und legen eine neue an.</p>
</aside>
<h2 is-upgraded><strong>Duplizieren des Quellcodes für eigene Anpassungen</strong></h2>
<p>Damit Ihnen über GitHub Aktualisierungen der Originaldateien zur Verfügung gestellt werden können (bspw. im Fall von Fehlern, s.u.) sollten Sie diese Dateien nicht editieren. Wir legen daher Kopien der beiden Notebook-Dateien an, bevor wir sie auf unsere Umgebung anpassen. Gehen Sie dazu im Jupyterlab-Dateibrowser in das Verzeichnis &#34;hska-dscb140-code&#34;, wählen Sie die beiden &#34;.ipynb&#34;-Dateien aus, klicken Sie auf die rechte Maustaste und führen Sie den Befehl &#34;Duplicate&#34; aus:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\1b51a95c0eb7c9e9.png"></p>
<p>Danach sollte das Dateisystem wie folgt aussehen:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\561e5c7bcceff2e5.png"></p>
<aside class="warning"><p><strong>Wichtig: </strong>Editieren Sie bitte nur die beiden Kopien. Sollten Sie Probleme mit GitHub haben können Sie jederzeit das gesamte Verzeichnis &#34;hska-dscb140-code&#34; auf Ihrer Jupyter-Instanz löschen und im Notebook Setup.ipynb die Zelle &#34;!git clone ...&#34; erneut ausführen.</p>
</aside>
<h2 is-upgraded><strong>Aktualisierung des Quellcodes im Falle von Änderungen</strong></h2>
<p>Sollten sich Änderungen im Originalquellcode auf GitHub ergeben (bspw. Korrekturen), dann können Sie diese über folgenden Befehl im Setup-Notebook einspielen lassen. Dies funktioniert nur, wenn Sie die Originaldateien nicht editiert haben, d.h. die Kopien im vorherigen Schritt angelegt haben:</p>
<pre><code># Aktualisieren des GitHub-Repositories für DSCB140 (nur bei Bedarf nötig, wird angekündigt)
!git -C ./hska-dscb140-code pull </code></pre>
<p>Es wird Ihnen jetzt angezeigt, dass Ihr Verzeichnis aktuell ist:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\cc3c885f9859d1a3.png"></p>
<p>Im Fall von Änderungen werden diese aufgelistet.</p>
<h2 is-upgraded><strong>Ergebnisse</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun eine lauffähige Jupyterlab-Instanz angelegt und um einen MySQL-Treiber für Python erweitert.</li>
<li>Zusätzlich haben Sie auf dieser Instanz in ein Verzeichnis (hska-dscb140-code) für diese Veranstaltung vorgegebenen Quellcode geladen.</li>
<li>Zwei der Quellcode-Dateien müssen Sie im nächsten Schritt um eigene Angaben ergänzen, weshalb Sie zur Vermeidung von Konflikten im GitHub-Verzeichnis Kopien dieser Jupyter-Notebooks angelegt haben.</li>
<li>Sie können nun das Notebook &#34;Setup&#34; schließen und in das Verzeichnis hska-dscb140-code wechseln (sofern nicht bereits geschehen).</li>
<li>Als nächstes werden wir die Datenbankverbindung konfigurieren.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Aktualisierung des bereitgestellten GitHub-Codes sowie Installation notwendiger Pakete" duration="2">
        <h2 is-upgraded><strong>Installation des Pakets &#34;sshtunnel&#34; für die verschlüsselte Verbindung</strong></h2>
<p>Bitte öffnen Sie nun das Notebook &#34;Setup&#34;. Legen Sie eine Zelle an, in der Sie das folgende Paket auf Ihrer JupyterHub-Instanz installieren (Achtung: mysql-connector sollte auch installiert sein, siehe vorheriger Schritt):</p>
<pre><code># nur einmal ausführen - Paket bleibt installiert solange Sie die Instanz nicht löschen
# Paket zum Zugriff auf die Übungsdatenbank über ssh-tunnel installieren
!pip install sshtunnel</code></pre>
<h2 is-upgraded><strong>Aktualisierung des Quellcodes</strong></h2>
<p>Als nächstes Aktualisieren Sie bitte die Quellcode-Dateien (Notebooks), die Ihnen über GitHub zur Verfügung gestellt werden:</p>
<pre><code># Aktualisieren des GitHub-Repositories für DSCB140 (nur bei Bedarf nötig, wird angekündigt)
!git -C ./hska-dscb140-code pull</code></pre>
<p>Im Fall von Änderungen werden diese aufgelistet:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\76e6a954e20a8089.png"></p>
<aside class="warning"><p>Sollte das Update nicht funktionieren, dann löschen Sie bitte den Ordner &#34;hska-dscb140-code&#34; komplett und führen Sie im Notebook &#34;Setup&#34; noch einmal &#34;!git clone <a href="https://github.com/pkuep/hska-dscb140-code.git" target="_blank">https://github.com/pkuep/hska-dscb140-code.git</a>&#34; aus.</p>
</aside>
<h2 is-upgraded><strong>Ergebnisse</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun Ihre Jupyterlab-Instanz um das notwendige Paket sshtunnel für den Zugriff auf die Übungsdatenbank erweitert und den Quellcode für diese Übung über GitHub heruntergeladen.</li>
<li>Als nächstes Konfigurieren wir die Datenbankverbindung.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Herstellen der Datenbankverbindung und optionaler Datenbank-Reset (Notebook &#34;Verbindung herstellen&#34;)" duration="5">
        <h2 is-upgraded><strong>Duplizieren der Notebooks</strong></h2>
<p>Bitte legen Sie Duplikate (rechte Maustaste → duplicate) der beiden Notebooks &#34;DSCB140 - Transaktionen - Verbindung herstellen&#34; sowie &#34;DSCB140 - Transaktionen - Übungen&#34; an. Arbeiten Sie bitte nur in den Kopien. </p>
<h2 is-upgraded><strong>Upload der SSH-Schlüsseldatei</strong></h2>
<p>In ILIAS finden Sie im Materialordner &#34;Infos zur Übungsdatenbank&#34; und darin eine Datei &#34;key&#34;. Laden Sie diese in Ihrer JupyterHub-Instanz in den Ordner &#34;hska-dscb140-code&#34; über Klick auf folgenden Button hoch:</p>
<p class="image-container"><img style="width: 504.60px" src="img\\d31fd4fb789a6ecb.png"></p>
<p>Die Datei muss im selben Ordner liegen wie die Jupyter Notebooks (also hska-dscb140-code).</p>
<h2 is-upgraded><strong>Test der Datenbankverbindung</strong></h2>
<p>Öffnen Sie Ihre Kopie des Notebooks &#34;DSCB140 - Transaktionen - Verbindung herstellen&#34;. Führen Sie die erste Zelle (imports) aus, damit alle notwendigen Pakete geladen sind.</p>
<ul>
<li>In der Zelle unter &#34;Notwendige Verbindungsparameter eingeben&#34; finden Sie folgende Variablen, für die Sie die Werte aus ILIAS ermitteln müssen (bzw. diese bereits aus der DBeaver-Einstellung kennen). In Bezug zur verschlüsselten SSH-Verbindung sind dies: (1) username_ssh, (2) password_ssh und (3) host_ssh. Diese Werte sind für alle Studierenden identisch.  </li>
<li>Die datenbankbezogenen Werte gelten pro Studierendem, d.h. (4) username_db, (5) password_db sowie (6) database sind individuell nach den Vorgaben in ILIAS analog zu DBeaver einzugeben. Folgende Abbildung zeigt den Zusammenhang der Informationen in ILIAS zu denen in Jupyter:</li>
</ul>
<p class="image-container"><img style="width: 624.00px" src="img\\101c9ce76e116d24.png"></p>
<p>Wenn Sie diese Zelle und die folgenden beiden Zellen zum Test der Verbindung ausführen, so sollten Ihnen zwei Datenbanken angezeigt werden:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\5feb2e9135cd3c6f.png"></p>
<aside class="special"><p><strong>Aufgabe</strong>: Kopieren Sie nun den Code aus &#34;Notwendige Verbindungsparameter&#34; in die Zwischenablage und fügen Sie ihn in die entsprechende Zelle in der Kopie des Notebooks &#34;DSCB140 - Transaktionen - Übungen&#34;. </p>
</aside>
<h2 is-upgraded><strong>Neu Aufsetzen der Datenbank (DDL-Struktur &amp; DML-Daten) - optional!</strong></h2>
<p>Sollten Sie die Übungen mit neuen Daten ausprobieren möchten, dann können Sie mit der Methode &#34;reset_and_fill_database(...)&#34; die Datenbank komplett zurücksetzen und &#34;frisch&#34; befüllen.</p>
<p>Führen Sie die Zelle aus bzw. geben Sie folgenden Code ein. </p>
<pre><code>reset_and_fill_database(tunnel, hostname_db, username_db, password_db, database)</code></pre>
<aside class="special"><p><strong>Hinweis</strong>: Sie können in beliebigen Notebooks, in denen Sie die SSH-Tunnel-Verbindung zur Datenbank hergestellt haben, diesen Reset der Datenbank durchführen. Sie benötigen dazu die Datei &#34;reset_and_fill_database.py&#34;, die im selben Ordner wie das Notebook liegen muss. Wenn die notwendigen Verbindungsparameter korrekt eingestellt sind, dann können Sie nach einem &#34;import reset_and_fill_database from reset_and_fill_database&#34; die Datenbank mit &#34;reset_and_fill_database(...)&#34; (s.o.) neu aufsetzen.</p>
</aside>
<h2 is-upgraded><strong>Ergebnisse</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun aus Jupyter und Python heraus eine verschlüsselte Verbindung zum Datenbankserver (mittels sshtunnel) hergestellt und sich darüber mit der Datenbank über das Paket mysql-connector testweise verbunden.</li>
<li>Die Einstellungen sind identisch zum Vorgehen in DBeaver. </li>
<li>Wir können nun insbesondere den Mehrbenutzerbetrieb simulieren, indem wir sowohl in DBeaver, als auch aus dem Jupyter Notebook &#34;DSCB140 - Integrität und Transaktionen - Übungen&#34; heraus mit der Datenbank interagieren.</li>
<li>Darüber hinaus haben Sie gegebenenfalls die Datenbank neu befüllt.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Einfügen eines beispielhaften Warenkorbs (Notebook &#34;Übungen&#34;)" duration="2">
        <p>Wechseln Sie nun in das Notebook &#34;DSCB140 - Transaktionen - Übungen&#34; und verbinden Sie sich mit der Datenbank. Als erstes definieren wir einen Testkunden, für den wir nun den Warenkorb in eine Bestellung überführen möchten. Führen Sie dazu die Zelle unter &#34;Beispielkunde und Bearbeiter&#34; aus:</p>
<pre><code># Beispieldaten
kunde = &#39;lea.schmidt@xy.de&#39;
bearbeiter = &#39;julia.meier@ab.de&#39;
bestellstatus = 1 # Bestellung erhält status &#34;bestellt&#34;</code></pre>
<p>Danach leeren wir den Warenkorb für die Kundin und fügen vier Beispielpositionen ein:</p>
<pre><code>with tunnel:
    # Verbindung aufbauen
    conn = mysql.connector.connect(host=hostname_db, user=username_db, passwd=password_db, autocommit=True, database=database, auth_plugin=&#39;mysql_native_password&#39;)
    cur = conn.cursor()
    
    try:
        # beispielhaften Warenkorb anlegen
        cur.execute(f&#34;delete from warenkorbposition where kunde_email = &#39;{kunde}&#39;&#34;)  # Warenkorb leeren
        cur.execute(f&#34;insert into warenkorbposition values (&#39;{kunde}&#39;, 1, 100), (&#39;{kunde}&#39;, 2, 200), (&#39;{kunde}&#39;, 3, 300), (&#39;{kunde}&#39;, 4, 400)&#34;)  # Warenkorb füllen
        
    except Exception as e:
        print(f&#34;{e}&#34;)    
    
    conn.close()</code></pre>
<aside class="special"><p><strong>Hinweis</strong>: Diese Zelle benötigen wir, um mehrmals die Überführung eines Warenkorbs in eine Bestellung testen zu können. Wir werden Sie also im nächsten Schritt auch nutzen.</p>
</aside>
<h2 is-upgraded><strong> Ergebnis</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun alle Vorbereitungen getroffen, so dass wir für einen Beispielkunden mit einer Transaktion einen Warenkorb in eine Bestellung überführen zu können.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Definition der Transaktion" duration="12">
        <h2 is-upgraded><strong>Basis: Schritte der Transaktion</strong></h2>
<p>Die Transaktion besteht aus mehreren SQL-Statements, die im Folgenden erklärt werden.</p>
<h3 is-upgraded>Nutzung von Variablen in SQL</h3>
<p>Zuerst legen wir drei SQL-Variablen an: eine für den Kunden, dessen Warenkorb überführt werden soll (@kunde), eine für den Mitarbeiter, der die neue Bestellung bearbeiten soll (@mitarbeiter), und eine Variable, die wir später nutzen werden, um die neu erzeugte Bestellnummer zwischenzuspeichern (@bestnr). Dies ist somit identisch zu dem Code in Jupyter unter &#34;Beispielkunde und Bearbeiter&#34;. Führen Sie die folgenden Zeilen aus:</p>
<pre><code>set @kunde = &#39;lea.schmidt@xy.de&#39;; -- store kunde in variable
set @mitarbeiter = &#39;julia.meier@ab.de&#39;; -- store mitarbeiter in variable
set @bestnr = 0; -- this variable will be filled with the newly generated bestnr</code></pre>
<h3 is-upgraded>Anlegen einer neuen Bestellung für die Kundin</h3>
<p>Danach können wir eine neue Bestellung für die Kundin anlegen und die automatisch generierte Bestellnummer in der Variablen @bestnr speichern. Wir lassen sie uns auch noch anzeigen:</p>
<pre><code>-- create order with auto-generated ID (timestamp &#34;now&#34;)
insert into bestellung (bestelldatum, bearbeitet_email, kunde, statusid) 
values (now(),@mitarbeiter, @kunde, 1);

-- retrieve order ID and store it in variable @bestnr
select last_insert_id() into @bestnr;

-- show @bestnr
select @bestnr;</code></pre>
<h3 is-upgraded>Kopieren der Warenkorbpositionen in Bestellpositionen der neuen Bestellung</h3>
<p>Als nächstes nutzen wir ein Subselect, um alle Warenkorbpositionen der Kundin zu erhalten und in die Tabelle Bestellposition unter Verwendung der neu erstellten Bestellnummer einzufügen. Hierzu nutzen wir die Möglichkeit in SQL, dass man konstante Werte in die SELECT-Abfrage aufnehmen kann. </p>
<p>Führen Sie zuerst folgendes SELECT-Statement aus, um das Prinzip der Verwendung von @bestnr zu verstehen:</p>
<pre><code>select @bestnr, pnr, menge 
from warenkorbposition w
where kunde_email = @kunde;</code></pre>
<p>Wir lassen uns hier den Warenkorb der Kundin anzeigen, fügen jeder Zeile aber noch eine Spalte mit einem konstantem Wert (dem von @bestnr) hinzu. Damit hat diese Abfrage genau das Format der Tabelle &#34;bestellposition&#34;. </p>
<p>Man kann in einem INSERT einfach die Ergebnisse eines SELECTs verwenden (anstelle von VALUES ...). Mit folgendem Statement lassen sich alle Warenkorbpositionen, inklusive der Referenz zur neuen @bestnr in die Tabelle Bestellposition einfügen:</p>
<pre><code>insert into bestellposition 
select @bestnr, pnr, menge 
from warenkorbposition w
where kunde_email = @kunde;
</code></pre>
<h3 is-upgraded><strong>Leeren des Warenkorbs</strong></h3>
<p>Zum Schluss möchten wir noch den Warenkorb der Kundin leeren:</p>
<pre><code>-- delete rows from basket
delete from warenkorbposition 
where kunde_email = @kunde;</code></pre>
<h2 is-upgraded><strong>Definition der Transaktion in DBeaver</strong></h2>
<p>Grundsätzlich arbeiten DBeaver und - falls nicht anders angegeben - auch der Python mysql-connector im sogenannten auto-commit Modus. Jedes SQL-Statement wird sofort nach dessen Ausführung versucht, in der Datenbank zu persistieren (zu &#34;committen&#34;). In DBeaver sehen wir dies oberhalb vom Code-Editor:</p>
<p class="image-container"><img style="width: 322.18px" src="img\\5c3e2ae9a25e9975.png"></p>
<p>In Python haben wir dies explizit beim Verbindungsaufbau angegeben:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\afbbe10532d53cfa.png"></p>
<p>Wenn wir nun die SQL-Statements ausführen ist somit nicht garantiert, dass diese als eine einzige, atomare Einheit angesehen werden. Das heißt, wenn bspw. Das letzte Statement nicht funktionieren sollte (die Gründe dafür sind hier irrelevant), dann wird nicht automatisch alles vorherige (Bestellung anlegen, Warenkorbpositionen kopieren) rückgängig gemacht. Somit ist in der Datenbank ein Zustand entstanden, den wir nicht vorliegen haben möchten!</p>
<p>Davor kann uns eine Transaktion schützen. Wenn wir alle Befehle als eine atomare Einheit definieren möchten, dann können wir eine Transaktion mit &#34;start transaction&#34; starten und am Ende mit einem expliziten &#34;commit&#34; diese beenden.</p>
<pre><code>-- Requirement: transfer customer basekt positions to a new order as one atomic operation that
--                                 can be rolled back if any of the single operations fails
start transaction;

-- create order with auto-generated ID (timestamp &#34;now&#34;)
insert into bestellung (bestelldatum, bearbeitet_email, kunde, statusid) 
values (now(), @mitarbeiter, @kunde, 1);
        
-- retrieve order ID and store it in variable @bestnr
select last_insert_id() into @bestnr;
        
-- insert all rows from basket into order positions using the retrieved order ID
insert into bestellposition 
select @bestnr, pnr, menge 
from warenkorbposition w
where kunde_email = @kunde;
        
        
-- delete rows from basket
delete from warenkorbposition 
where kunde_email = @kunde;

commit;</code></pre>
<p>Achtung: in DBeaver müssen Sie alle Codezeilen markieren und dann als Block ausführen, damit dies im Auto-Commit-Modus als eine Transaktion angesehen wird:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\da97a685a4d57dfc.png"></p>
<p>Mit folgendem Befehl lassen wir uns die neu angelegte Bestellung mit allen Positionen anzeigen:</p>
<pre><code>-- show new order with positions
select * 
from bestellung b 
left join bestellposition bp on b.bestnr = bp.bestnr
where b.bestnr = @bestnr;</code></pre>
<p>Es sollten nun alle Bestellpositionen und die neue Bestellnummer zu sehen sein (diese ist bei Ihnen sicherlich anders):</p>
<p class="image-container"><img style="width: 624.00px" src="img\\598aae208247cc0e.png"></p>
<p>Da der Warenkorb der Beispielkundin nun wieder leer ist können Sie diesen entweder in Python (Zelle &#34;Warenkorb vorbereiten&#34;) oder mittels folgenden Statements wieder befüllen:</p>
<h2 is-upgraded><strong>Ausführung der Transaktion in Python</strong></h2>
<p>Dieselbe Logik, die wir in DBeaver angewendet haben, kann durch folgende Code-Zeilen in Python umgesetzt werden (Achtung: das time.sleep(0) wird später erläutert).</p>
<pre><code>with tunnel:
    # Verbindung aufbauen
    conn = mysql.connector.connect(host=hostname_db, user=username_db, passwd=password_db, autocommit=False, database=database, auth_plugin=&#39;mysql_native_password&#39;)
    cur = conn.cursor()
    
    try:
        # Transaktion starten (alle folgenden Operationen gemeinsam als atomar betrachten)
        conn.start_transaction()
        print(&#34;Transaktion &#39;Warenkorb in Bestellung überführen&#39; begonnen&#34;)
        
        # Bestellung mit auto-generierte Bestellnummer anlegen
        sql = f&#34;insert into bestellung (bestelldatum, bearbeitet_email, kunde, statusid) values &#34; \
              f&#34;(now(), &#39;{bearbeiter}&#39;, &#39;{kunde}&#39;, {bestellstatus})&#34;
        print(f&#34;Führe aus: {sql}&#34;)
        cur.execute(sql)
        
        # ID der eingefügten Bestellung holen
        new_order_id = cur.lastrowid
        
        # ALle Positionen aus dem Warenkorb als Bestellpositionen übernehmen
        sql = f&#34;insert into bestellposition &#34; \
              f&#34;select {new_order_id}, pnr, menge from warenkorbposition w where kunde_email = &#39;{kunde}&#39;&#34;
        print(f&#34;Führe aus: {sql}&#34;)
        cur.execute(sql)        
        
        time.sleep(0)
        
        # Warenkorbpositionen löschen
        sql = f&#34;delete from warenkorbposition where kunde_email = &#39;{kunde}&#39;&#34;
        print(f&#34;Führe aus: {sql}&#34;)
        cur.execute(sql)
        
        # Transaktion abschließen (&#34;commit&#34;)
        conn.commit()
        print(f&#34;Transaktion &#39;Warenkorb in Bestellung überführen&#39; abgeschlossen. Neue Bestellnummer: {new_order_id}&#34;)
        
    except Exception as e:
        # Im Fehlerfall die bisherigen Änderungen rückgängig machen (&#34;rollback&#34;)
        print(f&#34;Fehler: {e}&#34;)
        print(f&#34;Bisherige Änderungen rückgänig machen. Neue Bestellnummer nicht mehr im System: {new_order_id}&#34;)
        conn.rollback()
            
    conn.close()</code></pre>
<aside class="warning"><p><strong>Achtung</strong>: Der Warenkorb der Beispielkundin ist nun wieder leer. Führen Sie im Jupyter Notebook erneut die Zelle &#34;Warenkorb vorbereiten&#34; aus.</p>
</aside>
<h2 is-upgraded><strong>Ergebnis</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun gelernt, wie Transaktionen sowohl in einem Tool wie DBeaver als auch aus einer Programmierumgebung wie Python gestartet werden können.</li>
<li>Als nächstes schauen wir uns den Nutzen von Transaktionen in verschiedenen Szenarien genauer an.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Fehler in Transaktion" duration="8">
        <h2 is-upgraded><strong>Fehler in DBeaver-Transaktion</strong></h2>
<p>Wir provozieren nun, dass das letzte SQL-Statement in unserer DBeaver-Transaktion nicht mehr funktioniert. Ändern Sie das Statement zum Beispiel wie folgt:</p>
<pre><code>-- delete rows from basket --&gt; ERROR
delete from warenkorbposition 
where kunde_em = @kunde;  -- attribute kunde_em does not exist</code></pre>
<p>Führen Sie die gesamte Transaktion erneut aus und prüfen Sie, ob die neue Bestellnummer angelegt wurde. Den auftretenden DBeaver &#34;Execution Error&#34; beantworten Sie bitte mit &#34;Stoppen&#34;:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\ca91887455326a96.png"></p>
<p>Schauen Sie sich mit folgendem Statement alle Bestellungen der Kundin an. Prüfen Sie, ob die neue Bestellung in der Datenbank bereits enthalten ist:</p>
<pre><code>select * 
from bestellung b 
left join bestellposition bp on b.bestnr = bp.bestnr
where b.bestnr = @bestnr;</code></pre>
<aside class="special"><p><strong>Erkenntnis</strong>: Offensichtlich schauen wir derzeit auf einen &#34;Zwischenzustand&#34; der Datenbank. Die neue Bestellung ist enthalten, obwohl sie aufgrund des Fehlers im letzten Statement nicht mehr hätte vorhanden sein sollen. Datenbanktools wie DBeaver machen nicht sofort automatisch alle vorherigen Statements rückgängig. Dies müssen wir explizit durch ein sogenanntes ROLLBACK vornehmen.</p>
</aside>
<p>Geben Sie in DBeaver folgendes Statement ein und führen Sie dieses aus. Prüfen Sie danach erneut, ob die neue Bestellung noch in der Datenbank vorhanden ist.</p>
<pre><code>rollback;</code></pre>
<aside class="special"><p><strong>Erkenntnis</strong>: Nach dem ROLLBACK ist die Datenbank wieder in einem von uns als konsistent definierten Zustand: Da beim Anlegen der Bestellung nicht alle Schritte sauber durchgelaufen sind, haben wir nun wieder keine Bestellung im System.</p>
</aside>
<h2 is-upgraded><strong>Fehler in Python-Transaktion</strong></h2>
<p>Provozieren Sie denselben Fehler in der Python-Transaktion. Schauen Sie sich den Code genau an und versuchen Sie nachzuvollziehen, wie das Programm mit einem Fehler umgeht.</p>
<aside class="special"><p><strong>Erkenntnis</strong>: In Python führt ein Fehler in einer Transaktion zu einem Ausnahmezustand (Exception). Diese Exception wird &#34;gefangen&#34; und im Fehlerfall wird das Rollback ausgeführt.</p>
</aside>
<p>Prüfen Sie in DBeaver, ob die in Python ausgegebene Bestellung wirklich nicht im System ist.</p>
<h2 is-upgraded><strong>Zusammenfassung</strong></h2>
<p>Im Falle von Fehlern erlaubt uns die Datenbank, alle Schritte bis zum Auftreten des Fehlers rückgängig zu machen (ROLLBACK). Damit werden inkonsistente und unerwünschte Zustände in unserem Datenmodell vermieden. Läuft alles einwandfrei durch, dann ist nach dem COMMIT die Transaktion abgeschlossen und die Daten sind vollständig konsistent.</p>
<p>Offensichtlich kann es aber auch &#34;Zwischenzustände&#34; im Rahmen von Transaktionen geben. Dies schauen wir uns im Folgenden genauer an.</p>
<h2 is-upgraded><strong>Ergebnis</strong></h2>
<ol type="1" start="1">
<li>Sie haben sowohl in DBeaver, als auch aus Python heraus in Ihrer Datenbank nun Transaktionen ausgeführt. Diese fassen mehrere atomare Operationen (SQL-Befehle) zu einer gesamten atomaren Operation zusammen. Schlägt einer der Befehle fehl, dann können wir durch ROLLBACK dennoch die Konsistenz sicherstellen. </li>
<li>Die Anwendung (bspw. die Website), die die Datenbank verwendet, muss dann entsprechend reagieren (bspw. dem User eine Fehlermeldung anzeigen, dass die Bestellung nicht abgeschlossen werden konnte).</li>
<li>Wir haben bisher absichtlich Fehler in den Code unserer Transaktion eingebaut. Dies ist natürlich ein Sonderfall, aber durch den Mehrbenutzerbetrieb und konkurrierenden Zugriff muss man bei Transaktionen immer damit rechnen, dass diese nicht vollständig erfolgreich durchlaufen kann.</li>
<li>Transaktionen sind somit ein sehr mächtiges Mittel, das von sehr großem Nutzen für RDBMS und die Konsistenz von Datenbanken darstellt.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Konkurrierende Zugriffe und deren Handling in Transaktionen" duration="10">
        <h2 is-upgraded><strong>Künstliche Verzögerung der (fehlerhaften) Transaktion</strong></h2>
<p>Um konkurrierende Zugriffe simulieren zu können werden wir nun die Transaktion in Python mittels &#34;sleep&#34;-Funktion verzögern. In der Zwischenzeit können wir in DBeaver testen, welche Auswirkungen unterschiedliche Isolationslevel haben.</p>
<p>Stellen Sie die Verzögerung innerhalb der Transaktion bspw. auf 20s. Lassen Sie die Transaktion weiterhin scheitern (durch den zuvor eingeführten Fehler, siehe Screenshot), damit das Einfügen einer Bestellung rückgängig gemacht wird (rollback):</p>
<p class="image-container"><img style="width: 624.00px" src="img\\24d474b72534217a.png"></p>
<h2 is-upgraded><strong>Einstellung Isolationsgrade (Fall 1: Lesezugriffe während Transaktion)</strong></h2>
<p>Starten Sie die Transaktion in Python und prüfen Sie, welche Isolationsgrade zu einer Anomalie führen. Um welche Anomalie handelt es sich? Zur Erinnerung:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\f54c108f0059e35a.png"></p>
<h2 is-upgraded><strong>Einstellung Isolationsgrade (Fall 2: Transaktion zwischen Lesezugriffen)</strong></h2>
<h3 is-upgraded><strong>Vorbereitungen</strong></h3>
<p>Stellen Sie die Verzögerung im Python-Skript wieder auf 0s. Entfernen Sie den Fehler, so dass am Ende der Transaktion eine Bestellung angelegt wird (commit soll ausgeführt werden). </p>
<p>Schalten Sie Ihre DBeaver Session um auf manuelles Commit und den Isolationsgrad auf &#34;Lesezugriff bestätigt&#34;:</p>
<p class="image-container"><img style="width: 306.50px" src="img\\5180deffe724384e.png"></p>
<p>Fügen Sie folgenden Code in DBeaver ein, anhand dessen wir verschiedene Isolationsgrade testen möchten:</p>
<pre><code>-- Vorbereitungen - Kunde setzen und Bestellhistorie leeren
set @kunde = &#39;lea.schmidt@xy.de&#39;;
delete from bestellung where kunde=@kunde;

-- Start der Transaktion (start transaction nicht nötig, da DBeaver auf manuelles Commit eingestellt)

-- erstes Lesen der Anzahl Bestellungen (leer)
select * from bestellung where kunde=@kunde; 

-- hier könnten weitere Befehle folgen 

-- UPDATE der Bestellung funktioniert (vgl. # Updated Rows! Widerspruch!)
update bestellung set bestelldatum = &#39;2000-01-01 00:00:01&#39; where kunde=@kunde;

-- Ende der Transaktion (commit nicht nötig, wird in DBeaver durch den Button &#34;Commit&#34; ausgelöst)

</code></pre>
<p>Führen Sie die Vorbereitungen (die ersten zwei Statements) aus, d.h. setzen Sie die Variable @kunde und leeren Sie alle Bestellungen der Kundin. Drücken Sie in DBeaver auf Commit, damit das Leeren wirksam wird:</p>
<p class="image-container"><img style="width: 192.00px" src="img\\e6bbe1fb37b37815.png"></p>
<h3 is-upgraded><strong>Nicht-blockerendes Lesen</strong></h3>
<p>Führen Sie das erste &#34;select * from ...&#34; aus (Strg+Enter). Damit sollte eine Transaktion in DBeaver gestartet sein. Dies ist erkennbar an der Historie:</p>
<p class="image-container"><img style="width: 370.00px" src="img\\3a6d32bd427a76c5.png"></p>
<p>Eine Query befindet sich somit bisher im Transaktions-Log. Wir haben darin die Bestellungen der Kundin ausgegeben. Da wir diese geleert haben ist die Ergebnismenge auch leer.</p>
<p>Als nächstes führen wir die Transaktion in Python aus. Eine Bestellung wird angelegt und die Transaktion wird &#34;committed&#34; (siehe print-Ausgabe in Jupyter): </p>
<p class="image-container"><img style="width: 624.00px" src="img\\f5ab0b0b8d36f01a.png"></p>
<p>Danach gehen wir wieder in DBeaver und führen den Rest unserer dortigen Transaktion aus (update bestellung ...). </p>
<p class="image-container"><img style="width: 624.00px" src="img\\1e4905801a82e017.png"></p>
<aside class="warning"><p><strong>Achtung</strong>: Wir befinden uns in derselben Transaktion und einmal wurden 0 Zeilen in Bestellung gelesen, im UPDATE wurde dann eine Zeile als aktualisierbar erkannt. Dies ist ein Widerspruch und ggf. könnte die Transaktionslogik zu langfristigen Inkonsistenzen führen.</p>
</aside>
<p>Die beobachtete Anomalie ist eine &#34;Phantom Row&#34;. Dieser Fall führt somit zu Inkonsistenzen in der DBeaver-Transaktion und es könnte Anwendungsfälle geben, bei denen dies kritisch ist. </p>
<p>Am Ende &#34;committen&#34; wir diese Transaktion und schließen sie damit ab. </p>
<p>Bitte löschen Sie erneut die Bestellungen der Kundin (denken Sie auch hier an das abschließende Commit).</p>
<h3 is-upgraded><strong>Blockierendes Lesen</strong></h3>
<p>Sollte das Ergebnis des ersten Lesevorgangs für die Konsistenz der gesamten Transaktion entscheidend sein, dann benötigen wir blockierendes Lesen, damit die &#34;Phantom Row&#34;-Problematik nicht auftreten kann.</p>
<p>Stellen Sie dazu die DBeaver-Transaktion auf &#34;Serializable&#34; um:</p>
<p class="image-container"><img style="width: 326.50px" src="img\\8c335862e3072a34.png"></p>
<p>Führen Sie die Schritte aus &#34;Nicht-blockierendes Lesen&#34; erneut durch. Was beobachten Sie?</p>
<p>Der nun eingestellte Modus erlaubt zwar das höchste Level an Konsistenz, jedoch kann sich die Blockierung von Transaktionen aufgrund von Lese-Statements negativ auf die Gesamtsystem-Latenz auswirken. Dies gilt insbesondere bei einer hohen Anzahl von Nutzern.</p>
<h3 is-upgraded><strong>Vermeidung eines &#34;Dirty Write&#34;</strong></h3>
<p>Abschließend möchten wir nun noch das Verhalten der Datenbank beobachten, durch das ein Schreibzugriff einer Transaktion sich auf den Zwischenzustand einer anderen Transaktion auswirkt. Dazu stellen wir time.sleep(20) ein, so dass die Python-Transaktion wieder zwischendrin 20s blockiert ist. Die DBeaver-Transaktion belassen wir auf &#34;Serialisierbar&#34;</p>
<p>Als nächstes führen wir diese aus und führen dann den update-Befehl aus unserer DBeaver-Transaktion aus. </p>
<p>Was beobachten Sie? Wie verhalten sich die anderen Isolationslevel?</p>


      </google-codelab-step>
    
      <google-codelab-step label="Jupyterlab-Instanz herunterfahren" duration="1">
        <h2 is-upgraded><strong>Herunterfahren der virtuellen Maschine (Jupyterlab)</strong></h2>
<p>Markieren Sie im Bereich &#34;AI platform → Notebooks&#34; in der Cloud Konsole Ihre Instanz und klicken Sie auf &#34;STOP&#34;:</p>
<p class="image-container"><img style="width: 624.00px" src="img\\350c36553038a3e0.png"></p>
<aside class="warning"><p><strong>Wichtig: </strong>Wenn Sie die Maschine löschen, dann müssen Sie auf einer neuen Maschine sämtliche Vorbereitungen (Download des Quellcodes von GitHub, Installation notwendiger Pakete, Einstellung der Verbindungsparameter etc.) erneut ausführen. Es ist daher empfohlen, die Maschine nur auszuschalten.</p>
</aside>
<h2 is-upgraded><strong>Ergebnis</strong></h2>
<ol type="1" start="1">
<li>Sie haben nun alle für dieses Codelab notwendigen Instanzen in GCP wieder heruntergefahren.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Glückwunsch" duration="1">
        <p>Herzlichen Glückwunsch, Sie haben nun eine wichtige Funktionalität von relationalen Datenbankmanagementsystemen kennengelernt: Transaktionen und Ablaufkonsistenz.</p>
<aside class="special"><p><strong>Hinweis: </strong>Sie können nun dieses Browser-Tab schließen.</p>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
